use std::{fmt::Debug, path::Path, sync::Arc};

use camino::Utf8PathBuf;
use chrono::{DateTime, Utc};
use lettre::{Address, AsyncSmtpTransport, AsyncTransport, Tokio1Executor, message, transport};
use sea_orm::{ConnectionTrait, DbErr};
use serde::Deserialize;
use tokio::sync::Mutex;

pub use clap::Parser;

mod database; // Imports the datatypes and logic generated by [`sea-orm-cli`] to interact with the SQL database
use crate::database::prelude::*;

/// Send only the transit notifications that users care about
#[derive(Parser)]
#[command(version)]
pub struct Args {
    /// Email address to send from
    #[arg(short, long)]
    #[cfg_attr(feature = "env", arg(env))]
    pub address: Address,

    /// Username for the SMTP relay server, will default to address
    #[arg(short, long)]
    #[cfg_attr(feature = "env", arg(env))]
    pub username: Option<String>,

    /// Password for the SMTP relay server
    #[arg(short, long)]
    #[cfg_attr(feature = "env", arg(env))]
    pub password: String,

    /// URL of the SMTP relay server
    #[arg(short, long)]
    #[cfg_attr(feature = "env", arg(env))]
    pub relay: String,

    /// Filename for the previous timestamp
    #[arg(short, long, default_value_t = Utf8PathBuf::from("timestamp.txt"))]
    #[cfg_attr(feature = "env", arg(env))]
    pub timestamp: Utf8PathBuf,

    /// Filename for database of users
    #[arg(short, long)]
    #[cfg_attr(feature = "env", arg(env))]
    pub database: sea_orm::ConnectOptions,
}

type Result<T> = std::result::Result<T, Error>;

/// Main entrypoint for this library which executes all the logic
pub async fn run<C: ConnectionTrait>(
    username: Option<String>,
    password: String,
    relay: &str,
    address: Address,
    incidents: impl IntoIterator<Item = Incident>,
    timestamp: impl AsRef<Path>,
    database: impl DatabaseFuture<C>,
) -> Result<()> {
    let transport = create_transport(
        username.clone().unwrap_or_else(|| address.to_string()),
        password,
        relay,
    )?;
    execute(timestamp, database, incidents, username, address, transport).await?;
    Ok(())
}

/// Test entrypoint to check the messages without actually sending them
pub async fn test_run<C: ConnectionTrait>(
    incidents: impl IntoIterator<Item = Incident>,
    timestamp: impl AsRef<Path>,
    database: impl DatabaseFuture<C>,
    address: Address,
) -> Result<()> {
    let transport = execute(
        timestamp,
        database,
        incidents,
        None,
        address,
        transport::stub::AsyncStubTransport::new_ok(),
    )
    .await?;
    for message in transport.messages().await {
        #[cfg(feature = "log")]
        log::info!("{message:?}");
        #[cfg(not(feature = "log"))]
        println!("{message:?}");
    }
    Ok(())
}

/// Checks the connection to the SMTP relay server
pub async fn test_connection(username: String, password: String, relay: &str) -> Result<bool> {
    let transport = create_transport(username, password, relay)?;
    let result = Ok(transport.test_connection().await?);
    transport.shutdown().await;
    result
}

/// Sets up the table definitions for [User], [Station], and [UserStation], useful in testing with in-memory SQLite databases
pub async fn setup_db(db: &impl sea_orm::ConnectionTrait) -> std::result::Result<(), DbErr> {
    let backend = db.get_database_backend();
    let schema = sea_orm::Schema::new(backend);

    let table_create_statements = [
        schema.create_table_from_entity(User),
        schema.create_table_from_entity(Station),
        schema.create_table_from_entity(UserStation),
    ];
    for statement in table_create_statements {
        db.execute(backend.build(&statement)).await?;
    }
    Ok(())
}

/// Actually handles all the business logic for gathering the notifications, filtering them by time and subscription for each user, and sending the email
async fn execute<C: ConnectionTrait, T: AsyncTransport<Error: Debug> + Send + Sync + 'static>(
    timestamp: impl AsRef<Path>,
    database: impl DatabaseFuture<C>,
    incidents: impl IntoIterator<Item = Incident>,
    username: Option<String>,
    address: Address,
    transport: T,
) -> Result<T> {
    // Needs to return the transport so [`test_run`] can display the messages
    let timestamp = fetch_and_update_timestamp(timestamp);
    let users: Vec<_> = fetch_users(database).await?;

    #[cfg(feature = "log")]
    log::trace!("{users:?}");

    let incidents: Vec<_> = filter_timestamp(incidents, timestamp.await?);
    #[cfg(feature = "log")]
    log::debug!("{incidents:?}");

    let message_builder = create_message_builder(username, address);
    let transport = Arc::new(Mutex::new(transport));

    let mut join_set = tokio::task::JoinSet::new();
    for user in users {
        join_set.spawn(process(
            // Processes each user in parallel
            incidents.clone(),
            user,
            message_builder.clone(),
            transport.clone(),
        ));
    }

    let results = join_set.join_all().await;
    let shutdown = transport.lock();
    for result in results {
        if let Err(error) = result {
            // If there is an error report it and continue
            #[cfg(feature = "log")]
            log::error!("{error}");
            #[cfg(not(feature = "log"))]
            eprintln!("{error}");
        }
    }

    shutdown.await.shutdown().await;
    match Arc::into_inner(transport) {
        Some(mutex) => Ok(mutex.into_inner()),
        None => Err(Error::PoisonError),
    }
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("File IO error: {0}")]
    IoError(#[from] tokio::io::Error),

    #[error("Failed to parse DateTime: {0}")]
    DateTimeError(#[from] chrono::ParseError),

    #[error("Failed to deserialize users: {0}")]
    DeserializeError(#[from] serde_json::Error),

    #[error("Error with SMTP transport: {0}")]
    SmtpError(#[from] transport::smtp::Error),

    #[error("Failed to send email: {0}")]
    SendError(String), // AsyncTransport::Error can be different types depending on the transport, but they all impl Debug

    #[error("Arc<Mutex<AsyncTransport>> is poisoned")]
    PoisonError, // I wonder if there is a better way to do this?

    #[error("Failed to generate email message: {0}")]
    EmailError(#[from] lettre::error::Error),

    #[error("Error with SQL database: {0}")]
    DbError(#[from] DbErr),

    #[error("Failed to parse email address: {0}")]
    AddressParseError(#[from] lettre::address::AddressError),
}

#[cfg_attr(test, derive(PartialEq))]
#[derive(Clone, Debug, Deserialize)]
pub struct Incident<D: AsRef<str> = String> {
    timestamp: DateTime<Utc>,
    description: D,
}

impl<D: AsRef<str>> Incident<D> {
    pub fn new(timestamp: DateTime<Utc>, description: D) -> Self {
        Incident {
            timestamp: timestamp,
            description: description,
        }
    }

    /// Checks if the incident message mentions any of the stations in the list
    fn mentions(&self, stations: &Vec<impl AsRef<str>>) -> bool {
        stations
            .into_iter()
            .any(|station| self.description.as_ref().contains(station.as_ref()))
    }
}

/// Reads the old timestamp value from and writes a new one to the file
async fn fetch_and_update_timestamp(path: impl AsRef<Path>) -> Result<DateTime<Utc>> {
    use tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt};

    let mut file = tokio::fs::File::options()
        .read(true)
        .write(true)
        .open(path)
        .await?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer).await?;
    let rewind = file.rewind();

    let current_time = Utc::now().to_rfc3339();
    rewind.await?;
    let write = file.write_all(current_time.as_bytes());
    let result = Ok(DateTime::parse_from_rfc3339(&buffer)?.to_utc());
    write.await?;
    result
}

/// Removes any incidents older than the timestamp so that users are not being sent the same messages over and over again
fn filter_timestamp<B: FromIterator<Incident>>(
    incidents: impl IntoIterator<Item = Incident>,
    timestamp: DateTime<Utc>,
) -> B {
    incidents
        .into_iter()
        .filter(|incident| incident.timestamp >= timestamp)
        .collect()
}

#[cfg_attr(test, derive(PartialEq, serde::Serialize))]
#[derive(Debug, Deserialize)]
struct Subscriber {
    email: Address,
    stations: Vec<String>,
}

// trait DatabaseFuture = Future<Output = std::result::Result<impl ConnectionTrait, DbErr>>;
// trait aliases are experimental <https://github.com/rust-lang/rust/issues/41517>
// So I am just going to define my own trait until that gets added

pub trait DatabaseFuture<C: ConnectionTrait>: Future<Output = std::result::Result<C, DbErr>> {}
impl<C: ConnectionTrait, T: Future<Output = std::result::Result<C, DbErr>>> DatabaseFuture<C> for T {}

// I only need access to the database in this function hence why I am asking for a future for the database connection rather than for the connection directly.
// Doing it this way also makes it so that the initial connection request is sent early and so it be processing or already done by the time this function is called.
// Plus this allows me to setup the tables for an in-memory SQLite database for testing before calling this function.
/// Fetches all of the users with the stations that they are subscribed to from the SQL database
async fn fetch_users<C: ConnectionTrait>(database: impl DatabaseFuture<C>) -> Result<Vec<Subscriber>> {
    use sea_orm::{EntityTrait, ModelTrait};

    let db = &database.await?;
    let users = User::find().all(db).await?;
    let mut subscribers = Vec::with_capacity(users.len()); // Trying to get rid of the unnecessary `mut` just makes things messy
    for user in users {
        let stations = user.find_related(Station).all(db).await?;
        subscribers.push(Subscriber {
            email: user.email.parse()?,
            stations: stations.into_iter().map(|station| station.name).collect(),
        })
    }
    Ok(subscribers)
}

// Pre-creates as much of the message as I can before copying it to be finished for each user
fn create_message_builder(username: Option<String>, address: Address) -> message::MessageBuilder {
    let mailbox = message::Mailbox::new(username, address);
    lettre::Message::builder()
        .from(mailbox)
        .subject("Transit Notification")
        .header(message::header::ContentType::TEXT_PLAIN)
}

/// Creates the backend transport to the SMTP relay server
fn create_transport(
    username: String,
    password: String,
    relay: &str,
) -> std::result::Result<AsyncSmtpTransport<Tokio1Executor>, lettre::transport::smtp::Error> {
    Ok(AsyncSmtpTransport::<Tokio1Executor>::relay(relay)?
        .credentials(transport::smtp::authentication::Credentials::new(
            username, password,
        ))
        .build())
}

/// Business logic for each individual user
async fn process(
    incidents: impl IntoIterator<Item = Incident>,
    user: Subscriber,
    message_builder: message::MessageBuilder,
    transport: Arc<Mutex<impl AsyncTransport<Error: Debug> + Send + Sync>>,
) -> Result<()> {
    #[cfg(feature = "log")]
    log::debug!("{user:?}");

    let incidents: Vec<_> = filter_stations(incidents, &user.stations);
    if let Some(message) = incidents_to_string(incidents) {
        #[cfg(feature = "log")]
        log::debug!("{}: {message}", user.email);

        let message = message_builder.to(user.email.into()).body(message)?;
        match transport.lock().await.send(message).await {
            Ok(_) => Ok(()),
            Err(error) => Err(Error::SendError(format!("{error:?}"))),
        }
    } else {
        // None of the stations the user is subscribed to have notices
        #[cfg(feature = "log")]
        log::debug!("{}: None", user.email);

        Ok(())
    }
}

/// Only keeps the notices for stations that the user is subscribed to
fn filter_stations<B: FromIterator<Incident>>(
    incidents: impl IntoIterator<Item = Incident>,
    stations: &Vec<impl AsRef<str>>,
) -> B {
    incidents
        .into_iter()
        .filter(|incident| incident.mentions(stations))
        .collect()
}

/// Message may be empty if there are no notices for an stations the user is subscribed to
fn incidents_to_string(incidents: impl IntoIterator<Item = Incident>) -> Option<String> {
    let mut message = String::new();
    for incident in incidents {
        message.push_str(&incident.description);
        message.push('\n');
    }
    if message.is_empty() {
        // [`incidents`] is an [`IntoIterator`], not [`ExactSizeIterator`] and thus it does not have the [`.len()`] function
        None
    } else {
        Some(message)
    }
}

#[cfg(test)]
mod test {
    use chrono::Utc;

    use super::Incident;

    #[tokio::test]
    async fn test_fetch_and_update_timestamp() {
        use tokio::fs;
        use tokio::io::AsyncWriteExt;

        let path = "timestamp.tmp";
        let timestamp = Utc::now();
        fs::File::options()
            .write(true)
            .create_new(true)
            .open(path)
            .await
            .unwrap()
            .write_all(timestamp.clone().to_rfc3339().as_bytes())
            .await
            .unwrap();
        let result = super::fetch_and_update_timestamp(path).await;
        match fs::remove_file(path).await {
            Ok(_) => {}
            Err(error) => eprintln!("Failed to remove {path}: {error}"),
        }
        assert_eq!(result.unwrap(), timestamp);
    }

    #[test]
    fn test_filter_on_timestamp() {
        use chrono::TimeZone;

        let before = Utc.with_ymd_and_hms(1999, 1, 1, 0, 0, 0).unwrap();
        let after = Utc.with_ymd_and_hms(2001, 1, 1, 0, 0, 0).unwrap();
        let after = Incident::new(after, String::from("After"));
        let incidents = [Incident::new(before, String::from("Before")), after.clone()];
        let timestamp = Utc.with_ymd_and_hms(2000, 1, 1, 0, 0, 0).unwrap();
        let mut results: Vec<_> = super::filter_timestamp(incidents, timestamp);
        assert_eq!(results.pop(), Some(after));
        assert_eq!(results.pop(), None);
    }

    #[tokio::test]
    async fn test_fetch_users() {
        use super::{
            Subscriber,
            database::{prelude::*, station, user, user_station},
            fetch_users,
        };
        use lettre::Address;
        use sea_orm::{ActiveValue, EntityTrait};

        let db = sea_orm::Database::connect("sqlite::memory:").await.unwrap();
        super::setup_db(&db).await.unwrap();

        let addresses =
            ["alice", "bob", "charlie"].map(|user| Address::new(user, "email.com").unwrap());
        let users = addresses.clone().map(|address| user::ActiveModel {
            email: ActiveValue::Set(address.to_string()),
            ..Default::default()
        });
        let users_len = users.len();

        User::insert_many(users)
            .on_conflict_do_nothing()
            .exec_without_returning(&db)
            .await
            .unwrap();
        let users = User::find().all(&db).await.unwrap();
        assert_eq!(users.len(), users_len);

        let station_names = ["foo", "bar", "baz"].map(|name| name.to_string());
        let stations = station_names.clone().map(|name| station::ActiveModel {
            name: ActiveValue::Set(name.to_string()),
            ..Default::default()
        });
        let stations_len = stations.len();

        Station::insert_many(stations)
            .on_conflict_do_nothing()
            .exec_without_returning(&db)
            .await
            .unwrap();
        let stations = Station::find().all(&db).await.unwrap();
        assert_eq!(stations.len(), stations_len);

        let user_stations = [
            user_station::ActiveModel {
                user_id: ActiveValue::Set(users[0].id),
                station_id: ActiveValue::Set(stations[0].id),
            },
            user_station::ActiveModel {
                user_id: ActiveValue::Set(users[0].id),
                station_id: ActiveValue::Set(stations[1].id),
            },
            user_station::ActiveModel {
                user_id: ActiveValue::Set(users[2].id),
                station_id: ActiveValue::Set(stations[2].id),
            },
        ];
        UserStation::insert_many(user_stations)
            .on_conflict_do_nothing()
            .exec_without_returning(&db)
            .await
            .unwrap();

        let subscribers = fetch_users(std::future::ready(Ok(db))).await.unwrap();
        let expected: Vec<_> = [
            vec![station_names[0].clone(), station_names[1].clone()],
            Vec::new(),
            vec![station_names[2].clone()],
        ]
        .into_iter()
        .zip(addresses)
        .map(|(stations, address)| Subscriber {
            email: address,
            stations: stations,
        })
        .collect();
        assert_eq!(subscribers, expected);
    }

    #[test]
    fn test_incidents_to_string() {
        use super::incidents_to_string;

        let some = [Incident::new(Utc::now(), String::from("foo"))];
        let none = [];
        assert!(incidents_to_string(some).is_some());
        assert!(incidents_to_string(none).is_none());
    }
}
